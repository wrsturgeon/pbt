use {
    crate::{
        size::{MaybeInfinite, MaybeInstantiable, MaybeOverflow},
        traits::{
            corner::Corner, decimate::Decimate, refine::Refine, rnd::Rnd, size::Size,
            weight::Weight,
        },
    },
    core::{convert::Infallible, iter},
    std::hint::unreachable_unchecked,
};

impl Size for () {
    const MAX_SIZE: MaybeInstantiable<MaybeInfinite<MaybeOverflow<usize>>> =
        MaybeInstantiable::Instantiable(MaybeInfinite::Finite(MaybeOverflow::Contained(0)));
    #[inline]
    fn size(&self) -> MaybeOverflow<usize> {
        MaybeOverflow::Contained(0)
    }
}

impl Weight for () {
    const MAX_WEIGHT: MaybeInstantiable<MaybeInfinite<usize>> =
        MaybeInstantiable::Instantiable(MaybeInfinite::Finite(0));
    #[inline]
    fn weight(&self) -> usize {
        0
    }
}

impl Corner for () {
    type Corners = iter::Once<Self>;
    #[inline]
    fn corners() -> Self::Corners {
        iter::once(())
    }
}

impl Rnd for () {
    #[inline]
    fn rnd<Rng: rand_core::RngCore>(
        _rng: &mut Rng,
        _expected_weight: usize,
    ) -> MaybeInstantiable<Self> {
        MaybeInstantiable::Instantiable(())
    }
}

impl Decimate for () {
    type Decimate = iter::Once<Self>;
    #[inline]
    fn decimate(&self) -> Self::Decimate {
        iter::once(())
    }
}

impl Refine for () {
    type Refine = iter::Once<Self>;
    #[inline]
    fn refine(&self) -> Self::Refine {
        iter::once(())
    }
}

impl Size for Infallible {
    const MAX_SIZE: MaybeInstantiable<MaybeInfinite<MaybeOverflow<usize>>> =
        MaybeInstantiable::Uninstantiable;
    #[inline]
    fn size(&self) -> MaybeOverflow<usize> {
        // SAFETY: Uninstantiable type.
        unsafe { unreachable_unchecked() }
    }
}

impl Weight for Infallible {
    const MAX_WEIGHT: MaybeInstantiable<MaybeInfinite<usize>> = MaybeInstantiable::Uninstantiable;
    #[inline]
    fn weight(&self) -> usize {
        // SAFETY: Uninstantiable type.
        unsafe { unreachable_unchecked() }
    }
}

impl Corner for Infallible {
    type Corners = iter::Empty<Self>;
    #[inline]
    fn corners() -> Self::Corners {
        iter::empty()
    }
}

impl Rnd for Infallible {
    #[inline]
    fn rnd<Rng: rand_core::RngCore>(
        _rng: &mut Rng,
        _expected_weight: usize,
    ) -> MaybeInstantiable<Self> {
        MaybeInstantiable::Uninstantiable
    }
}

impl Decimate for Infallible {
    type Decimate = iter::Empty<Self>;
    #[inline]
    fn decimate(&self) -> Self::Decimate {
        iter::empty()
    }
}

impl Refine for Infallible {
    type Refine = iter::Empty<Self>;
    #[inline]
    fn refine(&self) -> Self::Refine {
        iter::empty()
    }
}

impl<T: Size> Size for Option<T> {
    const MAX_SIZE: MaybeInstantiable<MaybeInfinite<MaybeOverflow<usize>>> = match T::MAX_SIZE {
        MaybeInstantiable::Uninstantiable => {
            MaybeInstantiable::Instantiable(MaybeInfinite::Finite(MaybeOverflow::Contained(0)))
        }
        MaybeInstantiable::Instantiable(MaybeInfinite::Infinite) => {
            MaybeInstantiable::Instantiable(MaybeInfinite::Infinite)
        }
        MaybeInstantiable::Instantiable(MaybeInfinite::Finite(finite)) => {
            MaybeInstantiable::Instantiable(MaybeInfinite::Finite(finite.plus(1)))
        }
    };
    #[inline]
    fn size(&self) -> MaybeOverflow<usize> {
        MaybeOverflow::Contained(0)
    }
}

impl<T: Weight> Weight for Option<T> {
    const MAX_WEIGHT: MaybeInstantiable<MaybeInfinite<usize>> =
        MaybeInstantiable::Instantiable(MaybeInfinite::Finite(0));
    #[inline]
    fn weight(&self) -> usize {
        0
    }
}

impl<T: Corner> Corner for Option<T> {
    type Corners = iter::Chain<iter::Once<Self>, iter::Map<T::Corners, fn(T) -> Self>>;
    #[inline]
    fn corners() -> Self::Corners {
        iter::once(None).chain(T::corners().map(Some as fn(_) -> _))
    }
}

impl<T: Rnd> Rnd for Option<T> {
    #[inline]
    fn rnd<Rng: rand_core::RngCore>(
        rng: &mut Rng,
        expected_weight: usize,
    ) -> MaybeInstantiable<Self> {
        MaybeInstantiable::Instantiable(
            if let Some(expected_weight) = expected_weight.checked_sub(1)
                && let MaybeInstantiable::Instantiable(some) = T::rnd(rng, expected_weight)
            {
                Some(some)
            } else {
                None
            },
        )
    }
}

impl<T: Decimate> Decimate for Option<T> {
    type Decimate = iter::Once<Self>;
    #[inline]
    fn decimate(&self) -> Self::Decimate {
        iter::once(())
    }
}

impl<T: Refine> Refine for Option<T> {
    type Refine = iter::Once<Self>;
    #[inline]
    fn refine(&self) -> Self::Refine {
        iter::once(())
    }
}

#[cfg(test)]
mod test {
    use super::*;

    crate::impl_tests!((), unit);
    crate::impl_tests!(Infallible, void);
}
